## 设计模式

> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。 —— Christopher Alexander

### SOLID 原则：

> "SOLID" 是由罗伯特·C·马丁在 21 世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。

1. 单一功能原则（Single Responsibility Principle）
2. 开放封闭原则（Opened Closed Principle）：对拓展开放，对修改封闭。
3. 里式替换原则（Liskov Substitution Principle）
4. 接口隔离原则（Interface Segregation Principle）
5. 依赖反转原则（Dependency Inversion Principle）

**设计模式的核心思是：封装变化** 我们将变换造成的影响 **最小化**，将变与不变进行分离，确保变化的部分灵活即：个性，不变的部分稳定即：共性。而这个过程就是 **封装变化**。

🌈 **简单工厂：** 将创建对象的过程单独封装。

> 🌰 要求一个系统具备给不同工种分配职责说明的功能。

```js
function User(name , age, career, work) {
    this.name = name
    this.age = age
    this.career = career
    this.work = work
}

function Factory(name, age, career) {
    let work
    switch(career) {
        case 'coder':
            work =  ['写代码','写系分', '修Bug']
            break
        case 'product manager':
            work = ['订会议室', '写PRD', '催更']
            break
        case 'boss':
            work = ['喝茶', '看报', '见客户']
        case 'xxx':
            // 其它工种的职责分配
            ...

    return new User(name, age, career, work)
}
// 我们思考一下这里的变与不变分别是什么？
1. 共性：  name、age、career、work
2. 个性：  取值不同

// 通过分析然后以这样的方式进行实现，我们要考虑的事情就会简单很多，或许你会写出这样的代码：

function Factory(name, age, career) {
    switch(career) {
        case 'coder':
            return new Coder(name, age)
            break
        case 'product manager':
            return new ProductManager(name, age)
            break
        ...
}

// 这样，那我们是否每得到一条数据都要去判断员工的工种，并去为每一个工种分配一个构造器呢？
```

🌈 **抽象工厂：**
