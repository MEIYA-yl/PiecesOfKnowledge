## CommonJS

> 在js发展前期，它主要是在浏览器环境发光发热，由于ES规范规范化的时间比较早，所以涵盖的范畴比较小，加上后端的js规范却远远落后，对于js自身而言，它的规范依然是十分薄弱的，还存在一些严重的缺陷，比如：没有模块标准。

### 1.0🌈与ES6模块区别：

1. commonJS 模块输出的是值的拷贝，ES6模块输出的是值的引用。

   - 通过es导入的变量是不能重新赋值修改的。

2. commonJS 模块是运行时加载，ES6模块是编译时输出接口。

   - commonJS只有运行时才能得到数据对象，导致没有办法在编译时做‘静态优化’。因此commonJS属于运行时才会加载模块的方式，即：运行时加载；
   - es模块导入`import {one, tow} form 'file'`, 这种加载在编译时就完成模块的加载，即：编译时加载 或者 静态加载；

3. CommonsJS 模块的 `require()`是同步加载模块，ES6 模块的`import`命令是异步加载，有独立的模块依赖的解析阶段；

   > 简单介绍一下：
   >
   > `同步加载`：所谓同步加载就是加载资源或者模块的过程会阻塞后续代码的执行；
   > `异步加载`：不会阻塞后续代码的执行；

### 1.1✨Commonjs模块规范

commonjs对模块的定义十分简单，主要分为`模块引用`、`模块定义`、`模块标识`三个部分。

### 1.1.1✨模块引用

模块引用的示例代码：`const fs = require('fs');`

在规范中，存在require()方法，这个方法接收`模块标识`，以此接入一个模块的API到当前上下文中。

### 1.1.2 ✨模块定义

除了引入的功能之外，上下文还提供了exports对象，用于导出当前模块的方法或者变量，并且它是唯一导出的出口；在模块中，还存在一个module对象，代表模块自身，而exports是module的属性，在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式：

```js
exports.add = function () {
    // ……
};
```

在另一个文件中，我们通过require()方法引入模块后，就能调用方法或者属性了：

```js
const math = require('math');
const result = math.add(10, 20);
```

### 1.2.3 ✨模块标识

模块标识其实就是传递给require()函数的参数，它必须是符合`小驼峰命名的字符串`，或者是 以 `.` 和 `..` 开头的相对路径或者绝对路径，它可以没有文件名后缀.js

模块的定义十分简单，接口也十分简洁，它的意义在于将累聚的方法或者变量限定在私有的作用域用，同时支持引入和导出功能以顺畅的衔接不同的模块（文件），每个模块具有独立的空间，它们互不干扰，在引用的时候也显得干净利落。

### 2.0🌈模块加载

现在我们正式的来认识一下CJs，在JS没有模块化之前，我们只能通过作用域划分利用对数据进行封装，文件划分、命名空间 和 IIFE。

1. 文件划分：文件划分是最原始的模块化实现方案，我们在使用前端框架进行开发时所利用的hooks的编码方式便与之有些类似，但不存在文件划分带来的缺陷，因为在导入时我们使用的是现代化的模块导入技术，也就是上边我们提到的ES模块机制。

   - 模块变量相当于是在全局进行了声明和定义，不同的模块中不可避免的存在有变量的命名冲突问题；
   - 由于全局定义的特点，导致无法确定变量的具体位置，为调试增加了困难；
   - 在不同的模块之间存在的依赖关系，导致在导入顺序上必须严格；

2. 命名空间：在早期的JQ中，这种方式是很常见的，它可以解决文件划分带来的一些问题但有些臃肿；

3. IIFE 立即执行函数：（每个IIFE都有自己的独立作用域），在私有作用域中的变量外界无法访问。我们来举个例子：

   ```js
   const modal = (()=>{
       funciton init(){
           say()
       }
       
       const say = ()=>{
           console.log(`这是一个利用 IIFE 来实现对数据的封装。`)
       }
       
       return res = {
           init()
       }
   })()
   ```

   🔔我们在来看一下导入和导出的代码是怎样进行加载的：

   ```js
   function loadModule(filename, module, require) {
     const wrappedSrc = `(function (module, exports, require) { 
         ${fs.readFileSync(filename, "utf8")}
         })(module, module.exports, require)`;
     eval(wrappedSrc);
   }
   // 实际上，原代码中还有额外两个参数： __filename和 __dirname，这就是我们在写代码的时候为什么可以使用到这两个变量的原因
   ```

   

