## 前端缓存技术与方案解析

> **背景：** 正常情况下我们向浏览器发送请求，然后服务将数据响应后的内容返回给用户；但当一台服务器可能要对及其庞大的客户端的请求进行响应，其中也有非常多的是重复的请求，会对服务器造成非常大的压力，所以：    我们会在客户端和服务器之间进行一些缓存，对于重复性请求的数据（如果已经存在于缓存中），在满足一定的条件的情况下就会直接去缓存中获取，而不会到达服务器。
>
> **意义：** 缓存的合理使用会直接影响到网页的性能。

### 前端到底有哪些缓存？

> **按照失效策略划分** HTTP 缓存
>
> 1. 强缓存
> 2. 协商缓存

> **按照缓存位置划分** 浏览器缓存
>
> 1. Service WorKer Cache
> 2. Memory Cache
> 3. Disk Cache
> 4. Push Cache

> **存储位置缓存**
>
> 1. Cookie
> 2. Web Storage
> 3. Indexed DB

### 一、从 HTTP 开始

> HTTP 的请求部分可以称为是前端工程师眼中的HTTP，请求以报文的形式发出：请求报文（请求行、请求报头、请求正文）和 响应报文（响应行、响应报头、响应正文）组成

- **强缓存：** 我们经常在第一次访问网站打开速度会有点慢，再次访问会发现快了许多，其背后主要就是强缓存起到了作用，强缓存在缓存数据未失效的情况下，客户端可以直接使用缓存数据，不用和数据可进行交互。	
  - 强缓存的放生过程：当浏览器在发起HTTP请求时，会向浏览器缓存进行一次询问，若浏览器没有该资源的缓存数据，那么浏览器便会向服务器发起请求，服务器将对应的请求资源数据返回给浏览器，浏览将资源的响应数据存储搭配浏览器缓存中。

- **协商缓存：** 协商缓存可以看做是强制缓存失效后，与服务器进行协商时浏览器携带缓存标识向服务器请求，由服务器根据缓存标识决定是否使用缓存的过程。
  - 由此可知浏览器启用协商缓存的前提是缓存失效。但反过来说，强制缓存失效并不代表一定导致浏览器启用协商缓存。

### **二、强缓存**

> 强缓存有关的首部字段主要有两个：Expires 和 Cache-Control

- **Expires  HTTP 1.0：**数据的缓存到期时间（是一个绝对时间，会受到客户端的时间影响而变的不精准），下一次请求时的请求时间小于服务端返回的到期时间，直接使用缓存数据（也就意味着包含该字段的资源命中了强缓存）。

- **Cache-Control  HTTP 1.1:** 

  - max-age字段（是一个相对时间，单位为 秒/S），表示缓存的内容将在一定的时间后失效。相对于 **Expires** 通过该字段命名的时间优先级更高。

  - s-maxage字段（被客户端与源服务器之间的代理服务器接收并缓存），优先级高于 **Expires**和 **max-age**指令定义的值。

  - public 和 private  前者表示该资源可以被客户端和代理服务器进行缓存，后者表示响应只可以被客户端缓存。**注意：**同时当 设置了Private指令后s-maxage指令将会被忽略，两者定位冲突。

  - no-store 和 no-cache 两者都不进行任何响应的缓存（后者比较特殊，资源会被缓存但会立即失效，下次发起请求验证资源是否过期），也就是说前者是真正意义上的不进行任何响应的缓存。、

    > no-cache 的使用场景：
    >
    > - 我们在meta标签的内修改资源的请求首部：
    >
    >   <meta http-equiv="Cache-Control" content="no-cache" />
    >
    > 当no-cache在请求头部被使用，表示告知（代理）服务器不直接使用缓存，要求向服务器发请求，而当在响应首部中被返回时，表示客户端可以缓存资源，但每次使用缓存资源都 **必须**现象服务器确认其有效性，这对每次访问都需要确认用户身份的应用很有用。

  - max-state = 30 30秒内即使缓存过期也是用该缓存

  - min-fresh = 30 希望在30秒内获取最新的响应

  

### **三、协商缓存：**

- **Last-Modified**	资源服务器在响应请求时，告诉浏览器资源的最后修改时间

- **If-Modified-Since**    再次请求服务器时，通过此字段通知服务器上次请求服务器返回的资源最后修改时间

  - 当浏览器在第一次接收到服务器返回的资源的 **Last-Modified**值后，会将该值存储起来，并在下一次访问该资源时携带由**If-Modified-Since**请求首部发送给服务器验证资源是否过期。

  > 示例 :
  >
  > ```bash
  > Last-Modified: Fri , 14 May 2021 17:23:13 GMT
  > If-Modified-Since: Fri , 14 May 2021 17:23:13 GMT
  > ```
  >
  > 1. 如果在 If-Modified-Since 字段指定的时间之后**资源发生了更新**，那么服务器会将更新的资源发送给浏览器（状态码200）并返回最新的 Last-Modified 值，浏览器收到资源后会更新缓存的 If-Modified-Since 的值。
  > 2. 如果在 If-Modified-Since 字段指定的时间之后**资源都没有发生更新**，那么服务器会返回状态码 `304 Not Modified` 的响应。
  >
  > 弊端 ：
  >
  > 1. 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
  >
  > 2. 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

- **Etag 与 If-None-Match** 代表资源的唯一标识，服务器按照指定的规则生成资源的标识。Etag 随着资源发生的变化更新；同样的当浏览器第一次接收服务器返回资源的Etag值后，会把这个值存储起来在下一次对该资源进行访问时通过携带 **if-None-Match**请求首部发送给服务器验证该资源是否过期。

  > 示例 : 
  >
  > ```bash
  > Etag: "29322-09SpAhH3nXWd8KIVqB10hSSz66"
  > If-None-Match: "29322-09SpAhH3nXWd8KIVqB10hSSz66"
  > ```
  >
  > 1. 如果服务器发现 If-None-Match 值与 Etag 不一致时，说明服务器上的文件已经被更新，那么服务器会发送更新后的资源给浏览器并返回最新的 Etag 值，浏览器收到资源后会更新缓存的 If-None-Match 的值。
  > 2. 由于**Last-Modified 与 If-Modified-Since**是根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match

- **实际使用策略：**

  > 需知：
  >
  > 	1.  精度上Etag要优于Last-Modified
  > 	1.  性能上Last-Modified要优于Etag
  > 	1.  优先级：服务校验优先考虑Etag

  - 对与频繁变动的资源：
    使用 `Cache-Control: no-cache`，使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。
  -  对于不常变化的资源：
    通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。

- 用户行为如何触发缓存

  - 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
  - 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
  - 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。

### **四、缓存的常见误区**：

> 资源的缓存在访问上时是有访问顺序的即：资源缓存是分级层的；

- 浏览器缓存：一般并专用于单个用户，在浏览器客户端中实现。它们通过避免多次获取相同的响应来提高性能。
- 本地代理：可能是用户自己安装的，也可能是由某个中介层管理的：比如公司的网络层或者网络提供商。本地代理通常会为多个用户缓存单个响应，这就构成了一种“公共”缓存。
- 源服务器缓存/CDN。由服务器控制，源服务器缓存的目标是通过为多个用户缓存相同的响应来减少源服务器的负载。CDN 的目标是相似的，但它分布在全球各个地区，然后通过分配给最近的一组用户来达到减少延迟的目的。

另外，我们也经常会使用本地配置的代理，这些代理能够通过配置信任证书来缓存 `HTTPS` 资源。



















